```C

#define MAX_LEN 153

void nNumCount(int* candidates, int candidatesSize, int target, int* returnSize, int** returnColumnSizes, int **ans, int sum, int index, int *number, int top) {
    if (sum > target) {
        return ;
    } else if (sum == target) {
        ans[*returnSize] = (int *)malloc(sizeof(int) * top);
        memcpy(ans[*returnSize], number, sizeof(int) * top);
        (*returnColumnSizes)[*returnSize] = top;
        *returnSize = *returnSize + 1;
    } else {
        for (int i = index; i < candidatesSize; ++i) {
            if (sum + candidates[i] <= target) {
              //这里不能修改sum与top的值，否则无法回溯
                int tmpSum = sum + candidates[i];
                number[top] = candidates[i];
                nNumCount(candidates, candidatesSize, target, returnSize, returnColumnSizes, ans, tmpSum, i, number, top + 1);
            }
        }
    }
}


int** combinationSum(int* candidates, int candidatesSize, int target, int* returnSize, int** returnColumnSizes){
    int **ans = (int **)malloc(sizeof(int *) * MAX_LEN);
    *returnColumnSizes = (int *)malloc(sizeof(int) * MAX_LEN);
    *returnSize = 0;
    int number[35];
    for (int i = 0; i < candidatesSize; ++i) {
        number[0] = candidates[i];
        nNumCount(candidates, candidatesSize, target, returnSize, returnColumnSizes, ans, number[0], i, number, 1);
    }
    return ans;
}
```

```java
class Solution {
    private List<List<Integer>> ans = new ArrayList<List<Integer>>();

    private List<Integer> number = new ArrayList<Integer>();

    public void nNumberCount(int[] candidates, int target, int sum, int index, List<Integer> number) {
        if (sum > target) {
            return ;
        } else if (sum == target) {
            ans.add(new ArrayList<Integer>(number));
            return ;
        } else {
            for (int i = index; i < candidates.length; ++i) {
                if (sum + candidates[i] <= target) {
                    number.add(candidates[i]);
                    nNumberCount(candidates, target, sum + candidates[i], i, number);
                    number.remove(number.size() - 1); //回溯到上一个状态
                }
            }
        }
    }

    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        for (int i = 0; i < candidates.length; ++i) {
            number.add(candidates[i]);
            nNumberCount(candidates, target, candidates[i], i, number);
            number.remove(number.size() - 1); //回溯到上一个状态
        }
        return ans;
    }
}
```

组合总数2，先排序，然后在dfs

```c
 void swap(int *a, int *b) {
     int tmp = *a;
     *a = *b;
     *b = tmp;
 }

 void QuickSort(int *candidates, int left, int right) {
    while (left < right) {
        int x = left;
        int y = right;
        int z = candidates[(x + y) / 2];
        do {
            while (candidates[x] < z) ++x;
            while (candidates[y] > z) --y;
            if (x <= y) {
                swap(&candidates[x], &candidates[y]);
                ++x;
                --y;
            }
        } while (x <= y);
        QuickSort(candidates, x, right);
        right = y;
    }
 }

void dfs(int* candidates, int candidatesSize, int target, int* returnSize, int** returnColumnSizes, int sum, int index, int *num, int top, int **ans) {
    if (sum > target) {
        return ;
    } else if (sum == target) {
        ans[*returnSize] = (int *)malloc(sizeof(int) * top);
        memcpy(ans[*returnSize], num, sizeof(int) * top);
        (*returnColumnSizes)[*returnSize] = top;
        *returnSize = *returnSize + 1;
        return ;
    } else {
        for (int i = index; i < candidatesSize; ++i) {
            if (sum + candidates[i] > target) break;
            if (i > index && candidates[i] == candidates[i - 1]) continue;
            else {
                num[top] = candidates[i];
                dfs(candidates, candidatesSize, target, returnSize, returnColumnSizes, sum + candidates[i], i + 1, num, top + 1, ans);
            }
        }
    }
    return ;
}

int** combinationSum2(int* candidates, int candidatesSize, int target, int* returnSize, int** returnColumnSizes){
    int **ans = (int **)malloc(sizeof(int) * 1001);
    *returnSize = 0;
    *returnColumnSizes = (int *)malloc(sizeof(int) * 1001);
    QuickSort(candidates, 0, candidatesSize - 1);
    int num[101];
    for (int i = 0; i < candidatesSize; ++i) {
        if (i > 0 && candidates[i] == candidates[ i - 1]) continue;
        if (candidates[i] > 0 && candidates[i] > target) break;
        num[0] = candidates[i];
        dfs(candidates, candidatesSize, target, returnSize, returnColumnSizes, candidates[i], i + 1, num, 1, ans);
    }
    return ans;
}
```

```java
class Solution {
    private List<List<Integer>> ans = new ArrayList<List<Integer>>();
    private List<Integer> number = new ArrayList<Integer>();

    public void dfs(int[] candidates, int target, int sum, int index) {
        if (sum > target) {
            return ;
        } else if (sum == target) {
            ans.add(new ArrayList(number));
            return ;
        } else {
            for (int i = index; i < candidates.length; ++i) {
                if (i > index && candidates[i] == candidates[i - 1]) continue;
                if (candidates[i] + sum > target) break;
                number.add(candidates[i]);
                dfs(candidates, target, sum + candidates[i], i + 1);
                number.remove(number.size() - 1);
            }
        }
    }

    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        Arrays.sort(candidates);
        for (int i = 0; i < candidates.length; ++i) {
            if (i > 0 && candidates[i] == candidates[i - 1]) continue;
            if (candidates[i] > 0 && candidates[i] > target) break;
            number.add(candidates[i]);
            dfs(candidates, target, candidates[i], i + 1);
            number.remove(number.size() - 1);
        }
        return ans;
    }
}
```

