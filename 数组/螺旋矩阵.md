

```c
//通过xMin xMax yMin yMax四个参数控制方向
// 循环退出的条件为存够的足够数据
//n*n的形状可以通过判断xMin<=xMax来判断是否需要进行循环，长方形时会多输出一个数
int* spiralOrder(int** matrix, int matrixSize, int* matrixColSize, int* returnSize){
    int xMin = 0;
    int yMin = 0;
    int xMax = matrixSize - 1;
    int yMax = matrixColSize[0] - 1;
    int maxNum = (xMax + 1) * (yMax + 1);
    int *ans = (int *) malloc(sizeof(int) * (maxNum + 1));
    int index = 0;
    while (index < maxNum) {
        for (int j = yMin; j <= yMax; ++j) {
            ans[index++] = matrix[xMin][j];
        }
        xMin++;
        if (index == maxNum) break;
        for (int i = xMin; i <= xMax; ++i) {
            ans[index++] = matrix[i][yMax];
        }
        yMax--;
        if (index == maxNum) break;
        for (int j = yMax; j >= yMin; --j) {
            ans[index++] = matrix[xMax][j];
           
        }
        xMax--;
        if (index == maxNum) break;
        for (int i = xMax; i >= xMin; --i) {
            ans[index++] = matrix[i][yMin];
        }
        yMin++;
        if (index == maxNum) break;
    }
    *returnSize = index;
    return ans;
}
```



```java
class Solution {
    private List<Integer> ans = new ArrayList<Integer>();
    public List<Integer> spiralOrder(int[][] matrix) {
        int xMin = 0;
        int yMin = 0;
        int xMax = matrix.length;
        int yMax = matrix[0].length;
        int maxCount = xMax * yMax;
        xMax--;
        yMax--;
        while (true) {
            for (int y = yMin; y <= yMax; ++y) {
                ans.add(matrix[xMin][y]);
            }
            if (ans.size() == maxCount) break;
            xMin++;
            for (int x = xMin; x <= xMax; ++x) {
                ans.add(matrix[x][yMax]);
            }
            if (ans.size() == maxCount) break;
            yMax--;
            for (int y = yMax; y >= yMin; --y) {
                ans.add(matrix[xMax][y]);
            }
            if (ans.size() == maxCount) break;
            xMax--;
            for (int x = xMax; x >= xMin; --x) {
                ans.add(matrix[x][yMin]);
            }
            if (ans.size() == maxCount) break;
            yMin++;
        }
        return ans;
    }
}
```

